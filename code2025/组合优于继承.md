在 Go 语言中，虽然没有传统面向对象的 “继承” 概念，但可以通过结构体嵌入（Embedding）实现类似继承的功能。不过 Go 社区更推崇 “组合优于继承” 的设计思想，因为组合能带来更低的耦合度、更高的灵活性和可扩展性。

继承例子
问题：
- 耦合紧密：EmailNotifier 和 SmsNotifier 强依赖 BaseNotifier，如果修改 BaseNotifier 的字段或方法，所有 “子类” 都可能受影响。
- 功能扩展受限：如果需要新增 “带模板的邮件通知”，要么修改 EmailNotifier（违反开闭原则），要么再嵌入一层，导致继承链臃肿。
- 语义模糊：嵌入结构体后，EmailNotifier 会 “继承” BaseNotifier 的所有字段和方法，可能暴露不必要的接口（如本场景中 BaseNotifier 的 Send 方法本应是抽象的）。
```go
package main

import "fmt"

// 基础通知结构体（类似父类）
type BaseNotifier struct {
	Recipient string // 接收者
}

// 基础发送方法（类似父类方法）
func (b *BaseNotifier) Send(text string) error {
	return fmt.Errorf("基础通知不支持发送，请使用具体通知类型")
}

// 邮件通知（嵌入BaseNotifier，类似继承）
type EmailNotifier struct {
	BaseNotifier // 嵌入基础结构体
	Subject      string // 邮件主题（扩展字段）
}

// 重写发送方法
func (e *EmailNotifier) Send(text string) error {
	fmt.Printf("发送邮件给 %s（主题：%s）：%s\n", e.Recipient, e.Subject, text)
	return nil
}

// 为邮件添加“附件”功能
func (e *EmailNotifier) AddAttachment(file string) error {
	fmt.Printf("邮件添加附件：%s\n", file)
	return nil
}

// 短信通知（嵌入BaseNotifier，类似继承）
type SmsNotifier struct {
	BaseNotifier // 嵌入基础结构体
}

// 重写发送方法
func (s *SmsNotifier) Send(text string) error {
	fmt.Printf("发送短信给 %s：%s\n", s.Recipient, text)
	return nil
}

func main() {
	// 邮件通知
	email := EmailNotifier{
		BaseNotifier: BaseNotifier{Recipient: "user@example.com"},
		Subject:      "测试邮件",
	}
	email.Send("这是一封测试邮件")
	email.AddAttachment("report.pdf")

	// 短信通知
	sms := SmsNotifier{
		BaseNotifier: BaseNotifier{Recipient: "13800138000"},
	}
	sms.Send("这是一条测试短信")
}
```

组合（通过接口和结构体组合） 例子

优势:
- 低耦合：每个组件（EmailSender、AttachmentProcessor）独立实现单一功能，修改一个组件不会影响其他组件。例如修改附件逻辑时，短信通知完全不受影响。
- 高灵活性：通过组合不同组件实现复杂功能。例如 EmailNotification 同时包含 Sender 和 AttachmentProcessor，而 SmsNotification 只需要 Sender，按需组合避免功能冗余。
- 易扩展性：新增功能时无需修改现有代码。例如添加 “带模板的邮件通知”，只需新增 TemplateEmailSender 实现 Sender 接口，再组合到 EmailNotification 中即可（符合开闭原则）。
- 清晰的语义：通过接口明确依赖（如 Sender 接口定义了 “发送” 行为），避免继承带来的 “隐式方法暴露” 问题。
```go
package main

import "fmt"

// 定义发送接口（抽象行为）
type Sender interface {
	Send(text string) error
}

// 邮件发送器（专注于邮件发送功能）
type EmailSender struct {
	Recipient string
	Subject   string
}

func (e *EmailSender) Send(text string) error {
	fmt.Printf("发送邮件给 %s（主题：%s）：%s\n", e.Recipient, e.Subject, text)
	return nil
}

// 附件处理器（独立组件，专注于附件功能）
type AttachmentProcessor struct {
	// 可以包含附件相关的配置（如最大大小、格式限制等）
}

func (a *AttachmentProcessor) AddAttachment(file string) error {
	fmt.Printf("添加附件：%s\n", file)
	return nil
}

// 短信发送器（专注于短信发送功能）
type SmsSender struct {
	Recipient string
}

func (s *SmsSender) Send(text string) error {
	fmt.Printf("发送短信给 %s：%s\n", s.Recipient, text)
	return nil
}

// 邮件通知（组合发送器和附件处理器）
type EmailNotification struct {
	Sender            // 包含发送接口（而非继承）
	*AttachmentProcessor // 包含附件功能组件
}

// 短信通知（仅组合发送器，不需要附件功能）
type SmsNotification struct {
	Sender // 包含发送接口
}

func main() {
	// 构建邮件通知（组合发送器和附件处理器）
	email := EmailNotification{
		Sender: &EmailSender{
			Recipient: "user@example.com",
			Subject:   "测试邮件",
		},
		AttachmentProcessor: &AttachmentProcessor{},
	}
	email.Send("这是一封测试邮件")       // 调用Sender接口的Send方法
	email.AddAttachment("report.pdf") // 调用附件处理器的方法

	// 构建短信通知（仅需要发送功能）
	sms := SmsNotification{
		Sender: &SmsSender{
			Recipient: "13800138000",
		},
	}
	sms.Send("这是一条测试短信")

	// 扩展：新增“带模板的邮件通知”（无需修改原有结构）
	templateEmail := EmailNotification{
		Sender: &TemplateEmailSender{ // 新的发送器实现Sender接口
			EmailSender: EmailSender{
				Recipient: "admin@example.com",
				Subject:   "模板邮件",
			},
			TemplateID: "welcome",
		},
		AttachmentProcessor: &AttachmentProcessor{},
	}
	templateEmail.Send("模板内容填充")
}

// 新增：带模板的邮件发送器（无需修改原有任何结构体）
type TemplateEmailSender struct {
	EmailSender  // 组合基础邮件发送器
	TemplateID   string // 新增模板ID字段
}

// 实现Sender接口，复用基础发送逻辑并扩展模板功能
func (t *TemplateEmailSender) Send(text string) error {
	fullText := fmt.Sprintf("[模板%s] %s", t.TemplateID, text)
	return t.EmailSender.Send(fullText) // 复用EmailSender的Send方法
}
```