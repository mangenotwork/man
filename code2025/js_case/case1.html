<html>

<body>
    <h4>case1</h4>

    <script type="text/javascript">
        document.write("<strong>" + (new Date()).toString() + "</strong>");
    </script>

    <div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>

    <canvas id="clock"></canvas>

</body>

<script>

    function case1() {
        for (var i1=0; i1<5; i1++) {
            setTimeout(console.log(i1), 0)
        }

        for (let i2=0; i2<5; i2++){
            setTimeout(console.log(i2), 0)
        }
    }

    function case2() {
        let a1 = "aaa"
        console.log(typeof(a1))
    }

    function case3() {
        console.log(Number(null))  // Number 转一个null 会变为0
        console.log(Number(undefined)) //  Number 转一个undefined 会变为 NaN
       

        // 一般的尽量使用 parseInt
        console.log(parseInt("11"))

        console.log(Number("")) // 会转为0
        console.log(parseInt(""))

        // 16进制转换
        console.log(Number("AF"))
        console.log(parseInt("AF"))
        console.log(parseInt("AF", 16)) // 有效

        // 其他类型转字符串
        let a1 = 1 
        let a1Str = a1.toString()
        console.log(typeof(a1Str))

    }

    // 字符串插值通过在${}中使用一个JavaScript表达式实现
    function case4() {
        let value = 5;
        let exponent = 'second';
        let interpolatedTemplateLiteral = `${ value } to the ${ exponent } power is ${value*value}`;
        console.log(interpolatedTemplateLiteral)
    }

    
    //在插值表达式中可以调用函数和方法：
    function case5() {
        function capitalize(word) {
            return `${ word[0].toUpperCase() }${ word.slice(1) }`;
        }
        console.log(`${ capitalize('hello') }, ${ capitalize('world') }! `); // Hello, World!
    }

    // Symbol（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险
    function case6() {
        let s = Symbol.for("aaaaaa")
        console.log(Symbol.keyFor(s))
    }
    
    // == 与 === 的区别
    function case7() {
        console.log("55" == 55)
        console.log("55" === 55) // 要验证类型
        console.log("55" != 55)
        console.log("55" !== 55) // 要验证类型
    }

    // for in
    function case8() {
        for (const propName in window) {
            document.write(`<p>${propName}</p>`)
        }
    }

    // with语句的用途是将代码作用域设置为特定的对象，其语法是：
    // with (expression) statement;
    // 使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利
    function case9() {
        with(location) {
            let qs = search.substring(1);
            let hostName = hostname;
            let url = href;
            console.log(qs)
            console.log(hostName)
            console.log(url)
        }
    }

    function case10() {
        let now = new Date();

        console.log(`${now.toLocaleDateString()} ${now.toLocaleTimeString()}`)
    }

    function case11() {
        let uri = "http://www.wrox.com/illegal value.js#start";
        console.log(encodeURI(uri));
        console.log(encodeURIComponent(uri));
        
        let uri2 = encodeURIComponent(uri)
        console.log(decodeURI(uri));
        console.log(decodeURIComponent(uri));

    }

    // eval()。这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串
    function case12() {
        let msg = "hello world";
        eval("console.log(msg)");

        eval("function sayHi() { console.log('hi'); }");
        sayHi();
    }
    
    // 如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用window.crypto. getRandomValues()
    function case13() {
        // 创建一个长度为10的Uint8Array
        const array = new Uint8Array(10);

        // 用随机值填充数组
        window.crypto.getRandomValues(array);

        console.log(array); // 输出包含随机值的数组
    }

    // Array.from()还接收第二个可选的映射函数参数。
    // 还可以接收第三个可选参数，用于指定映射函数中this的值。但这个重写的this值在箭头函数中不适用。
    function case14() {
        const a1 = [1, 2, 3, 4];
        const a2 = Array.from(a1, x => x**2);
        const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});
        console.log(a2);   // [1, 4, 9, 16]
        console.log(a3);   // [1, 4, 9, 16]
    }

    // Array.of()可以把一组参数转换为数组
    function case15() {
        console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
        console.log(Array.of(undefined));   // [undefined]
    }

    // 问题是判断一个对象是不是数组
    function case16() {
        let a = [1];
        if (a instanceof Array) {
            console.log("instanceof Array")
        }
        if (Array.isArray(a)) {
            console.log("Array.isArray")
        }
    }

    // 数组迭代器
    function case17() {
        let a = ["a", "b", "c"];
        console.log(a.entries()) // 不能直接使用
        console.log(Array.from(a.entries()))
    }

    // 排序方法
    function case18() {
        function compare(value1, value2) {
            if (value1.a < value2.a) {
                return -1;
            } else if (value1.a > value2.a) {
                return 1;
            } else {
                return 0;
            }

        }
        
        let values = [{a:10,b:1}, {a:2, b:2}, {a:4, b:3}];
        values.forEach((item, index) => {
            console.log(`索引 ${index}:`, item);
        });
        values.sort(compare);
        console.log("排序后")
        values.forEach((item, index) => {
            console.log(`索引 ${index}:`, item);
        });

        // 简化写法
        console.log("排序后 - b")
        values.sort((a, b) => a.b < b.b ? -1 : a.b > b.b ? 1 : 0);
        values.forEach((item, index) => {
            console.log(`索引 ${index}:`, item);
        });
    }

    // filter()方法。这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中
    function case19() {
        let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
        let filterResult = numbers.filter((item, index, array) => item > 2);
        console.log(filterResult);   // 3,4,5,4,3
    }
    
    // 归并  reduce()和reduceRight()的函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身
    function case20() {
        let values = [1, 2, 3, 4, 5];
        let sum = values.reduce((prev, cur, index, array) => prev + cur);
        console.log(sum);   // 15

        let sum2 = values.reduceRight(function(prev, cur, index, array){
            return prev + cur;
        });
        console.log(sum2);   // 15


        // reduceRight 与 reduce 一样 只是方向相反

    }

    function case21() {
        const m = new Map([
            ["key1", "val1"],
            ["key2", "val2"],
            ["key3", "val3"]
        ]);
        console.log([...m]); 

        // 字典循环
        m.forEach((val, key) => console.log(`${key} -> ${val}`));

    }

    // let values = [{a:10,b:1}, {a:2, b:2}, {a:4, b:3}];  筛选b大于1然后排序然后将a乘以2
    function case22() {
        let values = [{a:10,b:1}, {a:2, b:2}, {a:4, b:3}];

        const result = values.filter(({b})=>b>1).sort((a,b)=>a.b-b.b).map(({a,b})=>({a:a*2,b}));

        console.log(result);
    }


    // 如果对象原型链上的父类实现了Iterable接口，那这个对象也就实现了这个接口
    function case23() {
        class FooArray extends Array {}
        let fooArr = new FooArray('foo', 'bar', 'baz');
        for (let el of fooArr) {
            console.log(el);
        }
    }


    // 迭代器
    function case24() {
        // 可迭代对象
        let arr = ['foo', 'bar'];

        // 迭代器
        let iter = arr[Symbol.iterator]();
        console.log(iter); // ArrayIterator {}
        // 执行迭代
        console.log(iter.next()); 
        console.log(iter.next()); 
        console.log(iter.next()); 
    }
    

    // 自定义迭代器
    function case25() {
        class Counter {
            // Counter的实例应该迭代limit次
            constructor(limit) {
                this.count = 1;
                this.limit = limit;
            }
            next() {
                if (this.count <= this.limit) {
                return { done: false, value: this.count++ };
                } else {
                return { done: true, value: undefined };
                }
            }
            [Symbol.iterator]() {
                return this;
            }
        }

        let counter = new Counter(3);
        for (let i of counter) {
        console.log(i);
        }
    }

    // value属性是生成器函数的返回值，默认值为undefined，可以通过生成器函数的返回值指定
    function case26() {
        function* generatorFn() {
            return'foo';
        }
        let generatorObject = generatorFn();
        console.log(generatorObject);           // generatorFn {<suspended>}
        console.log(generatorObject.next());   // { done: true, value: 'foo'}
    }
    

    // 通过yield关键字退出的生成器函数会处在done: false状态；通过return关键字退出的生成器函数会处于done: true状态
    function case27() {
        function* generatorFn() {
            yield'foo';
            yield'bar';
            return 'baz';
        }
        let generatorObject = generatorFn();
        console.log(generatorObject.next());  //{done: false, value: 'foo'}
        console.log(generatorObject.next());  //{done: false, value: 'bar'}
        console.log(generatorObject.next());   // { done: true, value: 'baz' }
    }


    // 使用yield实现输入和输出
    // 第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数
    function case28() {
        function* generatorFn(initial) {
            console.log(initial);
            console.log(yield);
            console.log(yield);
        }
        let generatorObject = generatorFn('foo');
        generatorObject.next('bar');  //foo
        generatorObject.next('baz');   // baz
        generatorObject.next('qux');   // qux
    }


    // yield关键字可以同时用于输入和输出
    function case29() {
        function* generatorFn() {
            return yield'foo';
        }
        let generatorObject = generatorFn();
        console.log(generatorObject.next());         // { done: false, value: 'foo'}
        console.log(generatorObject.next('bar'));   // { done: true, value: 'bar' }
    }


    // 使用生成器实现范围和填充数组
    function case30() {
        function* range(start, end) {
            while(end > start) {
                yield start++;
            }
        }
        for (const x of range(4, 7)) {
            console.log(x);
        }
    
        function* zeroes(n) {
            while(n--) {
                yield 0;
            }
        }
        console.log(Array.from(zeroes(8))); // [0, 0, 0, 0, 0, 0, 0, 0]
    }

    
    // yield＊最有用的地方是实现递归操作，此时生成器可以产生自身
    function case31() {
        function* nTimes(n) {
            if (n > 0) {
                yield* nTimes(n-1);
                yield n-1;
            }
        }
        for (const x of nTimes(3)) {
            console.log(x);
        }
    }

    
    // 使用递归生成器结构和yield＊可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图
    function case32() {
        class Node {
            constructor(id) {
                this.id = id;
                this.neighbors = new Set();
            }
            connect(node) {
                if (node !== this) {
                    this.neighbors.add(node);
                    node.neighbors.add(this);
                }
            }
        }
        class RandomGraph {
            constructor(size) {
                this.nodes = new Set();
                // 创建节点
                for (let i = 0; i < size; ++i) {
                    this.nodes.add(new Node(i));
                }
                // 随机连接节点
                const threshold = 1 / size;
                for (const x of this.nodes) {
                    for (const y of this.nodes) {
                        if (Math.random() < threshold) {
                            x.connect(y);
                        }
                    }
                }
            }
            print() {
                for (const node of this.nodes) {
                    const ids = [...node.neighbors]
                                        .map((n) => n.id)
                                        .join(', ');
                    console.log(`${node.id}: ${ids}`);
                }
            }
        }

        const g = new RandomGraph(6);
        g.print();
    }

    
    // 要修改属性的默认特性，就必须使用Object.defineProperty()方法
    function case33() {
        let person = {};
        Object.defineProperty(person, "name", {
            writable: false,
            value: "Nicholas"
        });
        console.log(person.name); // "Nicholas"
        person.name = "Greg";
        console.log(person.name); // "Nicholas"
    }

    
    // 访问器属性是不能直接定义的，必须使用Object.defineProperty()
    // year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。
    function case34() {
        // 定义一个对象，包含伪私有成员year_和公共成员edition
        let book = {
            year_: 2017,
            edition: 1
        };

        Object.defineProperty(book, "year", {
            get() {
                return this.year_;
            },
            set(newValue) {
                if (newValue > 2017) {
                    this.year_ = newValue;
                    this.edition += newValue -2017;
                }
            }
        });
        book.year = 2018; // this.edition += newValue -2017;
        console.log(book.edition); // 2
    }


    // Object.assign()实际上对每个源对象执行的是浅复制
    function case35() {
        let dest, src, result;
        dest = { id: 'dest' };
        result = Object.assign(dest, { id: 'src1', a: 'foo' }, { id: 'src2', b: 'bar' });
        // Object.assign会覆盖重复的属性
        console.log(result); // { id: src2, a: foo, b: bar }
        // 可以通过目标对象上的设置函数观察到覆盖的过程：
        dest = {
            set id(x) {
                console.log(x);
            }
        };
        Object.assign(dest, { id: 'first' }, { id: 'second' }, { id: 'third' });
        // first
        // second
        // third
        
        //  对象引用
    
        dest = {};
        src = { a: {} };
        Object.assign(dest, src);
        // 浅复制意味着只会复制对象的引用
        console.log(dest);                  // { a :{} }
        console.log(dest.a === src.a);   // true

    }


    // 要检查超过两个值，递归地利用相等性传递即可
    function case36() {
        function recursivelyCheckEqual(x, ...rest) {
            return Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest));
        }
        console.log(recursivelyCheckEqual(1,2,1,"1"));
        console.log(recursivelyCheckEqual(1,1,1));
    }

    
    // 简写方法名与可计算属性键相互兼容
    function case37() {
        const methodKey = 'sayName';
        let person = {
            [methodKey](name){
                console.log(`My name is ${name}`);
            }
        }
        person.sayName('Matt'); // My name is Matt
    }


    // Object.values()和Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键/值对的数组
    function case38() {
        const o = {
            foo: 'bar',
            baz: 1,
            qux: {}
        };
        console.log(Object.values(o));
        // ["bar", 1, {}]
        console.log(Object.entries((o)));
        // [["foo", "bar"], ["baz", 1], ["qux", {}]]
    }


    // 原型链
    function case39() {

        function SuperType() {
            this.property = true;
        }

        SuperType.prototype.getSuperValue = function() {
            return this.property;
        };
        
        let a1 = new SuperType()
        console.log(a1.getSuperValue())

        function SubType() {
            this.subproperty = false;
        }

        // 继承SuperType
        SubType.prototype = new SuperType(); // 这个赋值重写了SubType最初的原型，将其替换为SuperType的实例

        SubType.prototype.getSubValue = function () {
            return this.subproperty;
        };
        

        let instance = new SubType();
        console.log(instance.getSuperValue()); // true

    }

    // 原型链的问题
    // 在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性
    function case40() {
        function SuperType() {
            this.colors = ["red", "blue", "green"];
        }
        function SubType() {}
        // 继承SuperType
        SubType.prototype = new SuperType();
        let instance1 = new SubType();
        instance1.colors.push("black");
        console.log(instance1.colors); // "red, blue, green, black"
        let instance2 = new SubType();
        console.log(instance2.colors); // "red, blue, green, black"
    }


    // Object.create() 在一个对象基础上copy一个对象
    // 这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）
    function case41() {
        let person = {
            name: "Nicholas",
            friends: ["Shelby", "Court", "Van"]
        };
        let anotherPerson = Object.create(person, {
            name: {
                value: "Greg"
            }
        });
        console.log(anotherPerson.name);   // "Greg"
    }

    // 类的构成
    // 类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。
    // 空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。
    function case42() {
        // 空类定义，有效
        class Foo {}
        // 有构造函数的类，有效
        class Bar {
            constructor() {}
        }
        // 有获取函数的类，有效
        class Baz {
            get myBaz() {}
        }
        // 有静态方法的类，有效
        class Qux {
            static myQux() {}
        }
    }

    // constructor关键字用于在类定义块内部创建类的构造函数。方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。
    function case43() {
        class Animal {}
        class Person {
            constructor() {
                console.log('person ctor');
            }
        }
        class Vegetable {
            constructor() {
                this.color = 'orange';
            }
        }
        let a = new Animal();
        let p = new Person();   // person ctor
        let v = new Vegetable();
        console.log(v.color);   // orange
    }


    // 类定义也支持获取和设置访问器
    function case44() {
        class Person {
            set name(newName) {
                this.name_ = newName;
            }
            get name() {
                return this.name_;
            }
        }
        let p = new Person();
        p.name = 'Jake';
        console.log(p.name); // Jake
    }


    // 使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象
    function case45() {
        class Vehicle {}
        // 继承类
        class Bus extends Vehicle {}
        let b = new Bus();
        console.log(b instanceof Bus);        // true
        console.log(b instanceof Vehicle);   // true
        function Person() {}
        // 继承普通构造函数
        class Engineer extends Person {}
        let e = new Engineer();
        console.log(e instanceof Engineer);   // true
        console.log(e instanceof Person);     // true

    }

    // 派生类的方法可以通过super关键字引用它们的原型
    function case46() {
        class Vehicle {
            constructor() {
                this.hasEngine = true;
            }
        }
        class Bus extends Vehicle {
            constructor() {
                // 不要在调用super()之前引用this，否则会抛出ReferenceError
                super(); // 相当于super.constructor()
                console.log(this instanceof Vehicle);   // true
                console.log(this);                          // Bus { hasEngine: true }
            }
        }
        new Bus();
    }

    // 在静态方法中可以通过super调用继承的类上定义的静态方法
    function case47() {
        class Vehicle {
            static identify() {
                console.log('vehicle');
            }
        }
        class Bus extends Vehicle {
            static identify() {
                super.identify();
            }
        }
        Bus.identify();   // vehicle
    }


    // 代理是使用Proxy构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出TypeError。
    function case48() {
        const target = {
            id: 'target'
        };
        const handler = {};
        const proxy = new Proxy(target, handler);
        // id属性会访问同一个值
        console.log(target.id);   // target
        console.log(proxy.id);    // target
        // 给目标属性赋值会反映在两个对象上
        // 因为两个对象访问的是同一个值
        target.id = 'foo';
        console.log(target.id); // foo
        console.log(proxy.id);   // foo
        // 给代理属性赋值会反映在两个对象上
        // 因为这个赋值会转移到目标对象
        proxy.id = 'bar';
        console.log(target.id); // bar
        console.log(proxy.id);   // bar
        // hasOwnProperty()方法在两个地方
        // 都会应用到目标对象
        console.log(target.hasOwnProperty('id')); // true
        console.log(proxy.hasOwnProperty('id'));   // true
        // Proxy.prototype是undefined
        // 因此不能使用instanceof操作符
        console.log(target instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check
        console.log(proxy instanceof Proxy);  // TypeError: Function has non-object prototype 'undefined' in instanceof check
        // 严格相等可以用来区分代理和目标
        console.log(target === proxy); // false
    }


    // 定义捕获器 
    function case49() {
        const target = {
            foo: 'bar'
        };
        const handler = {
            // 捕获器在处理程序对象中以方法名为键
            get() {
                return 'handler override';
            }
        };
        const proxy = new Proxy(target, handler);
        console.log(target.foo);                         // bar
        console.log(proxy.foo);                          // handler override
        console.log(target['foo']);                     // bar
        console.log(proxy['foo']);                       // handler override
        console.log(Object.create(target)['foo']);   // bar
        console.log(Object.create(proxy)['foo']);    // handler override
    }


    // 捕获器参数和反射API; 比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。
    function case50() {
        const target = {
            foo: 'bar'
        };
        const handler = {
            get(trapTarget, property, receiver) {
                console.log(trapTarget === target);
                console.log(property);
                console.log(receiver === proxy);
            }
        };
        const proxy = new Proxy(target, handler);
        proxy.foo;
        // true
        // foo
        // true
    }


    // 反射API为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：
    function case51() {
        const target = {
            foo: 'bar',
            baz: 'qux'
        };
        const handler = {
            get(trapTarget, property, receiver) {
                let decoration = '';
                if (property === 'foo') {
                decoration = '!!!';
                }
                return Reflect.get(...arguments) + decoration;
            }
        };
        const proxy = new Proxy(target, handler);
        console.log(proxy.foo);    // bar!!!
        console.log(target.foo);   // bar
        console.log(proxy.baz);    // qux
        console.log(target.baz);   // qux
    }


    // Proxy也暴露了revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。
    // 而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出TypeError。
    function case52() {
        const target = {
            foo: 'bar'
        };
        const handler = {
            get() {
                return 'intercepted';
            }
        };
        const { proxy, revoke } = Proxy.revocable(target, handler);
        console.log(proxy.foo);    // intercepted
        console.log(target.foo);   // bar
        revoke();
        console.log(proxy.foo);    // TypeError
    }


    // 跟踪属性访问, 通过捕获get、set和has等操作，可以知道对象属性什么时候被访问、被查询
    function case53() {
        const user = {
            name: 'Jake'
        };
        const proxy = new Proxy(user, {
            get(target, property, receiver) {
                console.log(`Getting ${property}`);
                return Reflect.get(...arguments);
            },
            set(target, property, value, receiver) {
                console.log(`Setting ${property}=${value}`);
                return Reflect.set(...arguments);
            }
        });
        proxy.name;      // Getting name
        proxy.age = 27; // Setting age=27
    }


    // 隐藏属性, 代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举
    function case54() {
        const hiddenProperties = ['foo', 'bar'];
        const targetObject = {
            foo: 1,
            bar: 2,
            baz: 3
        };
        const proxy = new Proxy(targetObject, {
            get(target, property) {
                if (hiddenProperties.includes(property)) {
                return undefined;
                } else {
                return Reflect.get(...arguments);
                }
            },
            has(target, property) {
                if (hiddenProperties.includes(property)) {
                return false;
                } else {
                return Reflect.has(...arguments);
                }
            }
        });
        // get()
        console.log(proxy.foo);   // undefined
        console.log(proxy.bar);   // undefined
        console.log(proxy.baz);   // 3
        // has()
        console.log('foo' in proxy);   // false
        console.log('bar' in proxy);   // false
        console.log('baz' in proxy);   // true

    }


    // 属性验证 因为所有赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值
    function case55() {
        const target = {
            onlyNumbersGoHere: 0
        };
        const proxy = new Proxy(target, {
            set(target, property, value) {
                if (typeof value !== 'number') {
                return false;
                } else {
                return Reflect.set(...arguments);
                }
            }
        });
        proxy.onlyNumbersGoHere = 1;
        console.log(proxy.onlyNumbersGoHere);   // 1
        proxy.onlyNumbersGoHere = '2';
        console.log(proxy.onlyNumbersGoHere);   // 1
    }


    // 函数与构造函数参数验证
    function case56() {
        function median(...nums) {
            return nums.sort()[Math.floor(nums.length / 2)];
        }
        const proxy = new Proxy(median, {
        apply(target, thisArg, argumentsList) {
            for (const arg of argumentsList) {
                if (typeof arg !== 'number') {
                    throw 'Non-number argument provided';
                }
            }
            return Reflect.apply(...arguments);
        }
        });
        console.log(proxy(4, 7, 1));   // 4
        console.log(proxy(4, '7', 1));
        // Error: Non-number argument provided

    }


    // 数据绑定与可观察对象
    function case57() {
        const userList = [];
        class User {
            constructor(name) {
                this.name_ = name;
            }
        }
        const proxy = new Proxy(User, {
            construct() {
                const newUser = Reflect.construct(...arguments);
                userList.push(newUser);
                return newUser;
            }
        });
        new proxy('John');
        new proxy('Jacob');
        new proxy('Jingleheimerschmidt');
        console.log(userList); // [User {}, User {}, User{}]

    }


    // 函数作为值
    function case58() {
        function callSomeFunction(someFunction, someArgument) {
            return someFunction(someArgument);
        }
        function add10(num) {
            return num + 10;
        }
        let result1 = callSomeFunction(add10, 10);
        console.log(result1);   // 20
        function getGreeting(name) {
            return "Hello, " + name;
        }
        let result2 = callSomeFunction(getGreeting, "Nicholas");
        console.log(result2);   // "Hello, Nicholas"

    }


    // 立即调用的匿名函数又被称作立即调用的函数表达式（IIFE, Immediately Invoked Function Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。
    /* 
    (function() {
      // 块级作用域
    })();
    */


    // then() 是 Promise 对象的核心方法，用于指定异步操作成功（成功或失败）时的处理逻辑。它是异步编程的重要语法，解决了传统回调函数嵌套过深的问题（回调地狱）
    function case59() {
        // 创建一个模拟异步操作的Promise
        const fetchData = new Promise((resolve, reject) => {
        setTimeout(() => {
            const success = true; // 模拟成功/失败
            if (success) {
            resolve("操作成功，返回数据：{ id: 1, name: '测试' }"); // 成功时调用resolve
            } else {
            reject(new Error("操作失败：网络错误")); // 失败时调用reject
            }
        }, 1000);
        });

        // 使用then处理结果
        fetchData
        .then(
            // 成功回调
            (result) => {
            console.log("成功处理：", result);
            },
            // 失败回调
            (error) => {
            console.log("失败处理：", error.message);
            }
        );
    }

    // then 链式调用  可以按顺序执行多个异步操作
    function case60() {
        // 第一个异步操作：获取用户ID
        const getUserID = () => {
        return new Promise((resolve) => {
            setTimeout(() => resolve(1001), 1000);
        });
        };

        // 第二个异步操作：根据ID获取用户名
        const getUserName = (id) => {
        return new Promise((resolve) => {
            setTimeout(() => resolve(`用户${id}：张三`), 1000);
        });
        };

        // 第三个异步操作：根据用户名获取详情
        const getUserDetail = (name) => {
        return new Promise((resolve) => {
            setTimeout(() => resolve(`${name}，年龄25，性别男`), 1000);
        });
        };

        // 链式调用：按顺序执行三个异步操作
        getUserID()
        .then((id) => {
            console.log("获取到ID：", id);
            return getUserName(id); // 返回下一个Promise
        })
        .then((name) => {
            console.log("获取到用户名：", name);
            return getUserDetail(name); // 返回下一个Promise
        })
        .then((detail) => {
            console.log("获取到用户详情：", detail);
        })
        .catch((error) => {
            // 统一捕获整个链条中的错误
            console.log("出错了：", error);
        });
    }

    
    // then 与 catch() 配合处理错误
    function case61() {
        const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error("故意出错了"));
        }, 1000);
        });

        promise
        .then((result) => {
            console.log("成功：", result); // 不会执行
        })
        .catch((error) => {
            console.log("捕获错误：", error.message); // 输出：捕获错误：故意出错了
        });
    }


    // 并行执行多个异步操作（Promise.all()）
    function case62() {
        // 模拟三个独立的异步请求
        const promise1 = new Promise(resolve => setTimeout(() => resolve("结果1"), 1000));
        const promise2 = new Promise(resolve => setTimeout(() => resolve("结果2"), 1500));
        const promise3 = new Promise(resolve => setTimeout(() => resolve("结果3"), 800));

        // 并行执行，等待所有操作完成
        Promise.all([promise1, promise2, promise3])
        .then(results => {
            console.log("所有操作完成：", results); // 按传入顺序返回结果
        })
        .catch(error => {
            console.log("有一个操作失败：", error); // 只要有一个失败就会触发
        });
    }


    // 捕获错误的两种方式
    function case63() {
        const promise = new Promise((resolve, reject) => {
            setTimeout(() => reject(new Error("故意出错")), 1000);
        });

        // 方式1：在 then 的第二个参数中捕获
        promise.then(
            result => console.log("成功：", result),
            error => console.log("错误（then）：", error.message)
        );

        // 方式2：用 catch 捕获（推荐，更清晰）
        promise
        .then(result => console.log("成功：", result))
        .catch(error => console.log("错误（catch）：", error.message));
    }


    // Promise.race() 是 Promise 的一个静态方法，它接收一个 Promise 数组作为参数，返回一个新的 Promise。
    // 这个新 Promise 会在数组中第一个状态改变的 Promise （无论论是成功还是失败）时，立即跟随其状态改变。
    // 简单说：Promise.race() 就像一场 "竞赛"，谁先完成（成功或失败），就以谁的结果为准。
    function case64() {
        // 三个不同延迟的 Promise
        const promise1 = new Promise((resolve) => {
            setTimeout(() => resolve("操作1（1秒）完成"), 1000);
        });

        const promise2 = new Promise((resolve) => {
            setTimeout(() => resolve("操作2（500毫秒）完成"), 500);
        });

        const promise3 = new Promise((resolve) => {
            setTimeout(() => resolve("操作3（1.5秒）完成"), 1500);
        });

        // 启动"竞赛"
        Promise.race([promise1, promise2, promise3])
        .then(result => {
            console.log("最快完成的操作结果：", result);
        })
        .catch(error => {
            console.log("最快失败的操作错误：", error);
        });
    }


    // Promise.race() 最常用的场景之一是为异步操作设置超时时间。如果网络请求太慢时，用超时 Promise 触发失败。
    function case65() {
        // 模拟一个可能很慢的网络请求
        function fetchData() {
            return new Promise((resolve) => {
                // 模拟网络延迟（这里故意设置为2秒，超过超时时间）
                setTimeout(() => {
                resolve("请求成功：返回数据");
                }, 2000);
            });
        }

        // 超时控制器：1秒后触发失败
        function timeoutPromise(ms) {
            return new Promise((_, reject) => {
                setTimeout(() => {
                reject(new Error(`请求超时（${ms}毫秒）`));
                }, ms);
            });
        }

        // 竞赛：正常请求 VS 超时控制器
        Promise.race([
            fetchData(),         // 实际请求
            timeoutPromise(1000) // 1秒超时
        ])
        .then(result => {
            console.log("成功：", result);
        })
        .catch(error => {
            console.log("失败：", error.message); // 会执行这里，因为请求超时了
        });
    }

    // 失败优先（只要有一个失败就立即返回）
    // 如果竞赛中有一个 Promise 先失败，Promise.race() 会立即返回失败状态
    function case66() {
        const successPromise = new Promise((resolve) => {
            setTimeout(() => resolve("成功结果"), 1000);
        });

        const failPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("我先失败了")), 500); // 更快失败
        });

        Promise.race([successPromise, failPromise])
        .then(result => {
            console.log("成功：", result); // 不会执行
        })
        .catch(error => {
            console.log("失败：", error.message); // 500毫秒后执行
        });
    }

    
    // async/await
    function case67() {
        async function foo() {
            let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3));
            console.log(await p);
        }
        foo();
    }


    // 一个简单的箭头函数就可以实现sleep()
    function case68() {
        async function sleep(delay) {
            return new Promise((resolve) => setTimeout(resolve, delay));
        }
        async function foo() {
            const t0 = Date.now();
            awaitsleep(1500);// 暂停约1500 毫秒
            console.log(Date.now() - t0);
        }
        foo();
    }


    // 窗口位置 有些浏览器可能会禁用
    function case69() {
        // 把窗口移动到左上角
        window.moveTo(0,0);
        // 把窗口向下移动100 像素
        window.moveBy(0, 100);
        // 把窗口移动到坐标位置(200, 300)
        window.moveTo(200, 300);
        // 把窗口向左移动50 像素
        window.moveBy(-50, 0);

        // 缩放到100×100
        window.resizeTo(100, 100);
        // 缩放到200×150
        window.resizeBy(100, 50);
        // 缩放到300×300
        window.resizeTo(300, 300);
        
        // 视口位置

        // 相对于当前视口向下滚动100 像素
        window.scrollBy(0, 100);
        // 相对于当前视口向右滚动40 像素
        window.scrollBy(40, 0);
        // 滚动到页面左上角
        window.scrollTo(0, 0);
        // 滚动到距离屏幕左边及顶边各100 像素的位置
        window.scrollTo(100, 100);


        window.open("https://www.baidu.com/",
                "wroxWindow",
                "height=400, width=400, top=10, left=10, resizable=yes");

    }


    // 系统对话框
    function case70() {
        if (confirm("Are you sure? ")) {
            alert("I'm so glad you're sure! ");
        } else {
            alert("I'm sorry to hear you're not sure.");
        }

    }


    // 系统输入框
    function case71() {
        let result = prompt("What is your name? ", "");
        if (result !== null) {
            alert("Welcome, " + result);
        }

    }

    // location 的url解析了查询字符串，并返回一个以每个查询参数为属性的对象
    function case72() {
        let getQueryStringArgs = function() {
            // 取得没有开头问号的查询字符串
            let qs = (location.search.length > 0 ? location.search.substring(1) : ""),
                // 保存数据的对象
                args = {};
            // 把每个参数添加到args对象
            for (let item of qs.split("&").map(kv => kv.split("="))) {
                let name = decodeURIComponent(item[0]),
                value = decodeURIComponent(item[1]);
                if (name.length) {
                    args[name] = value;
                }
            }
            return args;
        }
        console.log(getQueryStringArgs())

    }

    
    // navigator对象
    function case73() {
        console.log(window.navigator)
    }


    // 获取联网状态
    function case74() {
        const connectionStateChange = () => console.log(navigator.onLine);
        window.addEventListener('online', connectionStateChange);
        window.addEventListener('offline', connectionStateChange);
        // 设备联网时：
        // true
        // 设备断网时：
        // false

    }


    // querySelector()方法接收CSS选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回null
    function case75() {
        // 取得<body>元素
        let body = document.querySelector("body");
        // 取得ID为"myDiv"的元素
        let myDiv = document.querySelector("#myDiv");
        // 取得类名为"selected"的第一个元素
        let selected = document.querySelector(".selected");
        // 取得类名为"button"的图片
        let img = document.body.querySelector("img.button");
    }


    // querySelectorAll()也可以在Document、DocumentFragment和Element类型上使用
    function case76() {
        // 取得ID为"myDiv"的<div>元素中的所有<em>元素
        let ems = document.getElementById("myDiv").querySelectorAll("em");
        // 取得所有类名中包含"selected"的元素
        let selecteds = document.querySelectorAll(".selected");
        // 取得所有是<p>元素子元素的<strong>元素
        let strongs = document.querySelectorAll("p strong");

    }


    // 自定义数据属性
    // dataset属性是一个DOMStringMap的实例，包含一组键/值对映射。元素的每个data-name属性在dataset中都可以通过
    // data-后面的字符串作为键来访问（例如，属性data-myname、data-myName可以通过myname访问，但要注意data-my-name、data-My-Name要通过myName来访问）
    function case77() {
        // 本例中使用的方法仅用于示范
        let div = document.getElementById("myDiv");
        // 取得自定义数据属性的值
        let appId = div.dataset.appId;
        let myName = div.dataset.myname;
        // 设置自定义数据属性的值
        div.dataset.appId = 23456;
        div.dataset.myname = "Michael";
        // 有"myname"吗？
        if (div.dataset.myname){
        console.log(`Hello, ${div.dataset.myname}`);
        }

    }

    
    
    // case78 
    // canvas 2d 画一个时钟

    function case78() {
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('clock');
        const ctx = canvas.getContext('2d');
       
        
        // 设置Canvas尺寸，确保响应式显示
        function setupCanvas() {
            const baseSize = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            const size = Math.floor(baseSize);
            
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = `${size}px`;
            canvas.style.height = `${size}px`;
        }
        
        // 初始化Canvas尺寸
        setupCanvas();
        window.addEventListener('resize', setupCanvas); // 添加一个事件，窗口尺寸发生变化时，canvas画布也跟着变化
        
        // 绘制时钟函数
        function drawClock() {
            // 获取当前时间
            const now = new Date();
            const hours = now.getHours() % 12;
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const milliseconds = now.getMilliseconds();
            
            // 获取Canvas中心和半径
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 * 0.95;
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制时钟背景
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            
            // 绘制时钟边框
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.lineWidth = radius * 0.02;
            ctx.strokeStyle = '#333';
            ctx.stroke();
            
            // 绘制刻度
            for (let i = 0; i < 60; i++) {
                const angle = (i * Math.PI / 30) - Math.PI / 2;
                const length = i % 5 === 0 ? radius * 0.1 : radius * 0.05;
                const lineWidth = i % 5 === 0 ? radius * 0.015 : radius * 0.008;
                const startRadius = radius * 0.9;
                
                const startX = centerX + Math.cos(angle) * startRadius;
                const startY = centerY + Math.sin(angle) * startRadius;
                const endX = centerX + Math.cos(angle) * (startRadius - length);
                const endY = centerY + Math.sin(angle) * (startRadius - length);
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = i % 5 === 0 ? '#333' : '#999';
                ctx.stroke();
            }
            
            // 绘制数字
            for (let i = 1; i <= 12; i++) {
                const angle = (i * Math.PI / 6) - Math.PI / 2;
                const numberRadius = radius * 0.78;
                
                const x = centerX + Math.cos(angle) * numberRadius;
                const y = centerY + Math.sin(angle) * numberRadius;
                
                ctx.font = `bold ${radius * 0.08}px Arial, sans-serif`;
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i.toString(), x, y);
            }
            
            // 计算指针角度
            const secondAngle = ((seconds + milliseconds / 1000) / 60) * Math.PI * 2 - Math.PI / 2;
            const minuteAngle = ((minutes + seconds / 60) / 60) * Math.PI * 2 - Math.PI / 2;
            const hourAngle = ((hours + minutes / 60) / 12) * Math.PI * 2 - Math.PI / 2;
            
            // 绘制时针
            drawHand(hourAngle, radius * 0.5, radius * 0.04, '#333');
            
            // 绘制分针
            drawHand(minuteAngle, radius * 0.7, radius * 0.03, '#555');
            
            // 绘制秒针
            drawHand(secondAngle, radius * 0.85, radius * 0.02, '#e53e3e');
            
            // 绘制中心圆点
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.04, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.fill();

            // 中心的圆点 - 红色的部分
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.025, 0, Math.PI * 2);
            ctx.fillStyle = '#e53e3e';
            ctx.fill();
            
            // 继续动画   requestAnimationFrame 实现流畅动画
            // requestAnimationFrame是简单但实用的工具，可以让JavaScript跟进浏览器渲染周期，从而更加有效地实现网页视觉动效。
            requestAnimationFrame(drawClock);
        }
        
        // 绘制指针的辅助函数
        function drawHand(angle, length, width, color) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            const endX = centerX + Math.cos(angle) * length;
            const endY = centerY + Math.sin(angle) * length;
            ctx.lineTo(endX, endY);
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.lineCap = 'round';
            ctx.stroke();
        }
        
        // 开始动画
        drawClock();
    }

    case78()


    // 避免多次提交表单的代码
    function case79() {
        let form = document.getElementById("myForm");
        form.addEventListener("submit", (event) => {
            let target = event.target;
            // 取得提交按钮
            let btn = target.elements["submit-btn"];
            // 禁用提交按钮
            btn.disabled = true;
        });
    }

    
    // case80 屏蔽所有按键的输入
    /*
    textbox.addEventListener("keypress", (event) => {
        event.preventDefault();
    });
    */


    // case81   如果想只屏蔽特定字符，则需要检查事件的charCode属性，以确定正确的回应方式。例如，下面就是只允许输入数字的代码：
    /*
        textbox.addEventListener("keypress", (event) => {
            if(!/\\d/.test(String.fromCharCode(event.charCode))){
                event.preventDefault();
            }
        });
    */


    // 原子读和写
    function case82() {
        const sharedArrayBuffer = new SharedArrayBuffer(4);
        const view = new Uint32Array(sharedArrayBuffer);
        // 执行非原子写
        view[0] = 1;
        // 非原子写可以保证在这个读操作之前完成，因此这里一定会读到1
        console.log(Atomics.load(view, 0));//1
        // 执行原子写
        Atomics.store(view, 0, 2);
        // 非原子读可以保证在原子写完成后发生，因此这里一定会读到2
        console.log(view[0]); // 2

    }

    // 方法接收一个字符串参数，并以Uint8Array格式返回每个字符的UTF-8编码
    function case83() {
        const textEncoder = new TextEncoder();
        const decodedText = 'foo';
        const encodedText = textEncoder.encode(decodedText);
        // f的UTF-8 编码是0x66（即十进制102）
        // o的UTF-8 编码是0x6F（即二进制111）
        console.log(encodedText); // Uint8Array(3) [102, 111, 111]

        // 解码
        const textDecoder = new TextDecoder();
        // f的UTF-8 编码是0x66（即十进制102）
        // o的UTF-8 编码是0x6F（即二进制111）
        const encodedText1 = Uint8Array.of(102, 111, 111);
        const decodedText1 = textDecoder.decode(encodedText1);
        console.log(decodedText); // foo

    }

    // 流编码
    // TextEncoderStream其实就是TransformStream形式的TextEncoder。将解码后的文本流通过管道输入流编码器会得到编码后文本块的流：
    function case84() {
        async function * chars() {
            const decodedText = 'foo';
                for (let char of decodedText) {
                yield await new Promise((resolve) => setTimeout(resolve, 1000, char));
            }
        }
        const decodedTextStream = new ReadableStream({
            async start(controller) {
                for await (let chunk of chars()) {
                    controller.enqueue(chunk);
                }
                controller.close();
            }
        });
        constencodedTextStream=decodedTextStream.pipeThrough(newTextEncoderStream());
        const readableStreamDefaultReader = encodedTextStream.getReader();
        (async function() {
            while(true) {
                const { done, value } = await readableStreamDefaultReader.read();
                if (done) {
                break;
                } else {
                console.log(value);
                }
            }
        })();
        //Uint8Array[102]
        //Uint8Array[111]
        //Uint8Array[111]

    }


    // 流解码
    // TextDecoderStream其实就是TransformStream形式的TextDecoder。将编码后的文本流通过管道输入流解码器会得到解码后文本块的流：
    function case85() {
        async function * chars() {
            //每个块必须是一个定型数组
            constencodedText=[102, 111, 111].map((x)=>Uint8Array.of(x));
            for (let char of encodedText) {
                yield await new Promise((resolve) => setTimeout(resolve, 1000, char));
            }
        }
        const encodedTextStream = new ReadableStream({
            async start(controller) {
                for await (let chunk of chars()) {
                    controller.enqueue(chunk);
                }
                controller.close();
            }
        });
        constdecodedTextStream=encodedTextStream.pipeThrough(newTextDecoderStream());
        const readableStreamDefaultReader = decodedTextStream.getReader();
        (async function() {
            while(true) {
                const { done, value } = await readableStreamDefaultReader.read();
                if (done) {
                break;
                } else {
                console.log(value);
                }
            }
        })();
        //f
        //o
        //o

    }


    // case86 
    // FileReader类型表示一种异步文件读取机制。可以把FileReader想象成类似于XMLHttpRequest，只不过是用于从文件系统读取文件，而不是从服务器读取数据。
    //
    // 从表单字段中读取一个文件，并将其内容显示在了网页上。如果文件的MIME类型表示它是一个图片，那么就将其读取后保存为数据URI，
    // 在load事件触发时将数据URI作为图片插入页面中。如果文件不是图片，则读取后将其保存为文本并原样输出到网页上。progress事件
    // 用于跟踪和显示读取文件的进度，而error事件用于监控错误
    function case86() {
        let filesList = document.getElementById("files-list");
        filesList.addEventListener("change", (event) => {
            let info = "",
            output = document.getElementById("output"),
            progress = document.getElementById("progress"),
            files = event.target.files,
            type = "default",
            reader = new FileReader();
            if (/image/.test(files[0].type)) {
                reader.readAsDataURL(files[0]);
                type = "image";
            } else {
                reader.readAsText(files[0]);
                type = "text";
            }
            reader.onerror = function() {
                output.innerHTML = "Could not read file, error code is " +
                    reader.error.code;
            };
            reader.onprogress = function(event) {
                if (event.lengthComputable) {
                progress.innerHTML = `${event.loaded}/${event.total}`;
                }
            };
            reader.onload = function() {
                let html = "";
                switch(type) {
                case "image":
                    html = `<img src="${reader.result}">`;
                    break;
                case "text":
                    html = reader.result;
                    break;
                }
                output.innerHTML = html;
            };
        });

    }


    // case87 
    // blob表示二进制大对象（binary larget object），是JavaScript对不可修改二进制数据的封装类型。
    // 包含字符串的数组、ArrayBuffers、ArrayBufferViews，甚至其他Blob都可以用来创建blob。Blob构造
    // 函数可以接收一个options参数，并在其中指定MIME类型
    function case87() {
        console.log(new Blob(['foo']));
        // Blob {size: 3, type: ""}
        console.log(new Blob(['{"a": "b"}'], { type: 'application/json' }));
        // {size: 10, type: "application/json"}
        console.log(new Blob(['<p>Foo</p>', '<p>Bar</p>'], { type: 'text/html' }));
        // {size: 20, type: "text/html"}

        let filesList = document.getElementById("files-list");
        filesList.addEventListener("change", (event) => {
            let info = "",
                output = document.getElementById("output"),
                progress = document.getElementById("progress"),
                files = event.target.files,
                reader = new FileReader(),
                blob=blobSlice(files[0], 0, 32);
            if (blob) {
                reader.readAsText(blob);
                reader.onerror = function() {
                output.innerHTML = "Could not read file, error code is " +
                            reader.error.code;
                };
                reader.onload = function() {
                output.innerHTML = reader.result;
                };
            } else {
                console.log("Your browser doesn't support slice().");
            }
        });


    }


    // case88 页面可以使用全局对象Notification向用户请求通知权限。这个对象有一个requestPemission()方法，
    // 该方法返回一个期约，用户在授权对话框上执行操作后这个期约会解决。
    function case88() {
        Notification.requestPermission()
        .then((permission) => {
          console.log('User responded to permission request:', permission);
        });

    }


    // 因为在JavaScript中读写cookie不是很直观，所以可以通过辅助函数来简化相应的操作
    function case89() {
        class CookieUtil {
            static get(name) {
                let cookieName = `${encodeURIComponent(name)}=`,
                    cookieStart = document.cookie.indexOf(cookieName),
                    cookieValue = null;
                if (cookieStart > -1){
                let cookieEnd = document.cookie.indexOf("; ", cookieStart);
                if (cookieEnd == -1){
                    cookieEnd = document.cookie.length;
                }
                cookieValue = decodeURIComponent(document.cookie.substring(cookieStart
                    + cookieName.length, cookieEnd));
                }
                return cookieValue;
                }
                static set(name, value, expires, path, domain, secure) {
                let cookieText =
                    `${encodeURIComponent(name)}=${encodeURIComponent(value)}`
                if (expires instanceof Date) {
                    cookieText += `; expires=${expires.toGMTString()}`;
                }
                if (path) {
                    cookieText += `; path=${path}`;
                }
                if (domain) {
                    cookieText += `; domain=${domain}`;
                }
                if (secure) {
                    cookieText += "; secure";
                }
                document.cookie = cookieText;
                }
                static unset(name, path, domain, secure) {
                CookieUtil.set(name, "", new Date(0), path, domain, secure);
            }
        };

        // 设置cookie
        CookieUtil.set("name", "Nicholas");
        CookieUtil.set("book", "Professional JavaScript");
        // 读取cookie
        alert(CookieUtil.get("name")); // "Nicholas"
        alert(CookieUtil.get("book")); // "Professional JavaScript"
        // 删除cookie
        CookieUtil.unset("name");
        CookieUtil.unset("book");
        // 设置有路径、域和过期时间的cookie
        CookieUtil.set("name", "Nicholas", "/books/projs/", "www.wrox.com",
                        new Date("January 1, 2010"));
        // 删除刚刚设置的cookie
        CookieUtil.unset("name", "/books/projs/", "www.wrox.com");
        // 设置安全cookie
        CookieUtil.set("name", "Nicholas", null, null, null, true);

    }


    // 


</script>

</html>



